https://medium.freecodecamp.org/a-short-overview-of-object-oriented-software-design-c7aa0a622c83
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
1. abstraction:Abstraction is the idea of simplifying a concept to its bare essentials in some context. It allows you to better understand the concept by stripping it down to a simplified version.

The examples above illustrate abstraction — look at how the Fight class is structured. The way you use it is as simple as possible — you give it two heroes as arguments in instantiation and call the fight() method. Nothing more, nothing less.

Abstraction in your code should follow the rule of least surprise. Your abstraction should not surprise anybody with needless and unrelated behavior/properties. In other words — it should be intuitive.
abstraction reduces complexity by hiding unnecessary detail.
==============================================================================
2. encapsulation:Encapsulation can be thought of as putting something inside a capsule.In most languages, this is done through the so-called access modifiers (private, protected, and so on). 
-------------------------------------------------------------------------------
3. polymorphism: something occurs in several different forms. static or compile-time and dynamic.
    static: implement multiple methods within the same class that use the same name but a different set of parameters. 
    That is called method      overloading and represents a static form of polymorphism.
    
    Dynamic polymorphism: This form of polymorphism doesn’t allow the compiler to determine the executed method. Within an inheritance
    hierarchy, a subclass can override a method of its superclass. That enables the developer of the subclass to customize or 
    completely replace the behavior of that method.
    
    code: https://csharp-station.com/Tutorial/CSharp/Lesson09

It also creates a form of polymorphism. Both methods, implemented by the super- and subclass, share the same name and parameters but provide different functionality.

3.1 Inheritance:
============================================================================
4. aggregation:Defines a weak “has-a” relationship between a whole and its parts. Considered weak, because the parts can exist without the whole.
Example: HeroInventory and Item. 
A HeroInventory can have many Items and an Item can belong to any HeroInventory(such as trading items).
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5. composition:A strong “has-a” relationship where the whole and the part cannot exist without each other. The parts cannot be shared, as the whole depends on those exact parts.
---------------------------------------------------------
6. association:  Defines a loose relationship between two components. Both components do not depend on one another but may work together.
   Example: Hero and a Zone object.
-----------------------------------------------------------
7. Generalization:
Generalization might be the most important design principle — it is the process of extracting shared characteristics and combining them in one place. All of us know about the concept of functions and class inheritance —both are a kind of generalization.

A comparison might clear things up: while abstraction reduces complexity by hiding unnecessary detail, generalization reduces complexity by replacing multiple entities which perform similar functions with a single construct.
------------------------------------------------------------------------------------------
8. Decomposition
Decomposition is the action of splitting an object into multiple separate smaller parts. Said parts are easier to understand, maintain and program.
----------------------------------
9. abstract class vs interface

10. protected vs protected internal
